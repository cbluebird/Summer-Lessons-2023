# Query 查询参数
+ Query 参数是在 URL 中的一部分，用于向服务器发送额外的数据，由键值对组成，以 `?` 为起始符号，键值对之间使用 `&` 分隔，例如：`/user/search?name=XiMo&age=3`
+ Query 参数常用于 HTTP GET 请求
+ 常见的地方有搜索（浏览器等等）
	+ ![Pasted image 20230713112250.png](https://img1.imgtp.com/2023/07/13/fksrMZry.png)
Gin 里面给我们封装的 Context 参数提供了丰富的方法帮我们获取 Query 参数

| Query方法     | 说明                                                                                 |
| ------------- | ------------------------------------------------------------------------------------ |
| Query         | 获取key对应的值，不存在返回空字符串                                                  |
| DefaultQuery  | key不存在时返回一个默认值                                                            |
| GetQuery      | 获取key对应的值，并且返回bool标识，标识成功或者失败                                  |
| QueryArray    | 获取key对应的值，值是一个字符串数组，不存在返回空字符串数组                          |
| GetQueryArray | 获取key对应的值，并且返回bool标识，标识成功或者失败                                  |
| QueryMap      | 获取key对应的值，值是一个字符串map[string]string，不存在返回空                       |
| GetQueryMap   | 获取key对应的值，值是一个字符串map[string]string，并且返回bool标识，标识成功或者失败 |
需要注意的是通过 Query 获取到的参数都是 string 类型

下面是一些代码示例：
```go
package main

import (
    "github.com/gin-gonic/gin"
)

func Query(c *gin.Context) {
    // 访问 /query?name=ximo&age=3&sex=
    // Query 获取key对应的值，不存在返回空字符串
    nameQuery := c.Query("name")
    ageQuery := c.Query("age")
    sexQuery := c.Query("sex")
    organizationQuery := c.Query("organization")
    c.JSON(200, gin.H{
        "nameQuery":         nameQuery,
        "ageQuery":          ageQuery,
        "sexQuery":          sexQuery,
        "organizationQuery": organizationQuery,
    })

    // // 访问 /query?name=ximo&age=3&sex=
    // // DefaultQuery key不存在时返回一个默认值
    // organizationDefaultQuery := c.DefaultQuery("organization", "精弘网络")
    // sexDefaultQuery := c.DefaultQuery("sex", "male")
    // nameDefaultQuery := c.DefaultQuery("name", "惜寞")
    // c.JSON(200, gin.H{
    //  "organizationDefaultQuery": organizationDefaultQuery,
    //  "sexDefaultQuery":          sexDefaultQuery,
    //  "nameDefaultQuery":         nameDefaultQuery,
    // })

    // // 访问 /query?name=ximo&age=3&sex=
    // // GetQuery 获取key对应的值，并且返回bool标识，标识成功或者失败
    // nameGetQuery, nameExist := c.GetQuery("name")
    // sexGetQuery, sexExist := c.GetQuery("sex")
    // organizationGetQuery, orgaorganizationExist := c.GetQuery("organization")
    // c.JSON(200, gin.H{
    //  "nameGetQuery":          nameGetQuery,
    //  "nameExist":             nameExist,
    //  "sexGetQuery":           sexGetQuery,
    //  "sexExist":              sexExist,
    //  "organizationGetQuery":  organizationGetQuery,
    //  "orgaorganizationExist": orgaorganizationExist,
    // })

    // // 访问 /query?name=ximo&age=3&sex=&hobby=code&hobby=sleep&hobby=
    // // QueryArray
    // hobbyQuery := c.Query("hobby")
    // hobbyQueryArray := c.QueryArray("hobby")
    // nameQueryArray := c.QueryArray("name")
    // sexQueryArray := c.QueryArray("sex")
    // organizationQueryArray := c.QueryArray("organization")
    // c.JSON(200, gin.H{
    //  "hobbyQuery":             hobbyQuery,
    //  "hobbyQueryArray":        hobbyQueryArray,
    //  "nameQueryArray":         nameQueryArray,
    //  "sexQueryArray":          sexQueryArray,
    //  "organizationQueryArray": organizationQueryArray,
    // })

    // // 访问 /query?name=ximo&age=3&sex=&hobby=code&hobby=sleep&hobby=
    // // GetQueryArray
    // hobbyGetQueryArray, hobbyExist := c.GetQueryArray("hobby")
    // nameGetQueryArray, nameExist := c.GetQueryArray("name")
    // sexGetQueryArray, sexExist := c.GetQueryArray("sex")
    // organizationGetQueryArray, orgaorganizationExist := c.GetQueryArray("organization")
    // c.JSON(200, gin.H{
    //  "hobbyGetQueryArray":        hobbyGetQueryArray,
    //  "hobbyExist":                hobbyExist,
    //  "nameGetQueryArray: ":       nameGetQueryArray,
    //  "nameExist":                 nameExist,
    //  "sexGetQueryArray":          sexGetQueryArray,
    //  "sexExist":                  sexExist,
    //  "organizationGetQueryArray": organizationGetQueryArray,
    //  "orgaorganizationExist":     orgaorganizationExist,
    // })

    // // 访问 /query?user[name]=ximo&user[age]=3&user[sex]=&user[hobby]=code&user[hobby]=sleep
    // // QueryMap
    // userQueryMap := c.QueryMap("user")
    // adminQueryMap := c.QueryMap("admin")
    // c.JSON(200, gin.H{
    //  "userQueryMap":  userQueryMap,
    //  "adminQueryMap": adminQueryMap,
    // })

    // // 访问 /query?user[name]=ximo&user[age]=3&user[sex]=&user[hobby]=code&user[hobby]=sleep
    // // GetQueryMap
    // userGetQueryMap, userExist := c.GetQueryMap("user")
    // adminGetQueryMap, adminExist := c.GetQueryMap("admin")
    // c.JSON(200, gin.H{
    //  "userGetQueryMap":  userGetQueryMap,
    //  "userExist":        userExist,
    //  "adminGetQueryMap": adminGetQueryMap,
    //  "adminExist":       adminExist,
    // })
}
  
func main() {
    r := gin.Default()

    r.GET("/query", Query)

    r.Run(":8080")
}
```

# Param 动态参数
+ Param 参数获取到的数据类型也是 string 类型
+ 路由形式一般写成 `/user/:name/:age`，这里的 `:` 表示后面的参数是一个占位符
+ 请求的参数可以通过 URL 路径传递，`name` 和 `age` 可以通过访问 `/user/XiMo/3` 这个路由去获取 `XiMo` 和 `3` ，访问 `/user/惜寞/4` 可以获取 `惜寞` 和 `4`

Gin 给我们提供了 Param 方法去获取这些参数：
```go
package main

import (
    "github.com/gin-gonic/gin"
)

func main() {
    r := gin.Default()
  
    // 注意会匹配 /param/XiMo 但不会匹配 /param/ 或者 /param
    r.GET("/param/:name", func(c *gin.Context) {
        // 访问 /param/XiMo
        name := c.Param("name")

        // 不存在会返回空字符串
        age := c.Param("age")
  
        c.JSON(200, gin.H{
            "name": name,
            "age":  age,
        })
    })
  
    r.Run(":8080")
}
```

# PostForm 表单参数
+ 和 Query 很像，不同之处在于数据不通过 URL 来传递，而是处于请求的主体当中
+ 表单参数常用于 POST 请求中

Gin 提供的 PostForm 函数与 Query 基本上一一对应的，具体情况见下表：

| Query方法     | PostForm方法     | 说明                                                                                 |
| ------------- | ---------------- | ------------------------------------------------------------------------------------ |
| Query         | PostForm         | 获取key对应的值，不存在返回空字符串                                                  |
| DefaultQuery  | DefaultPostForm  | key不存在时返回一个默认值                                                            |
| GetQuery      | GetPostForm      | 获取key对应的值，并且返回bool标识，标识成功或者失败                                  |
| QueryArray    | PostFormArray    | 获取key对应的值，值是一个字符串数组，不存在返回空字符串数组                          |
| GetQueryArray | GetPostFormArray | 获取key对应的值，并且返回bool标识，标识成功或者失败                                  |
| QueryMap      | PostFormMap      | 获取key对应的值，值是一个字符串map[string]string，不存在返回空                       |
| GetQueryMap   | GetPostFomMap    | 获取key对应的值，值是一个字符串map[string]string，并且返回bool标识，标识成功或者失败 |
下面是一些代码示例：
```go
package main

import (
    "github.com/gin-gonic/gin"
)

func PostForm(c *gin.Context) {
    // PostForm 获取key对应的值，不存在返回空字符串
    // name=ximo&age=3&sex=
    namePostForm := c.PostForm("name")
    agePostForm := c.PostForm("age")
    sexPostForm := c.PostForm("sex")
    organizationPostForm := c.PostForm("organization")
    c.JSON(200, gin.H{
        "namePostForm":         namePostForm,
        "agePostForm":          agePostForm,
        "sexPostForm":          sexPostForm,
        "organizationPostForm": organizationPostForm,
    })

    // // DefaultPostForm key不存在时返回一个默认值
    // // name=ximo&age=3&sex=
    // organizationDefaultPostForm := c.DefaultPostForm("organization", "精弘网络")
    // sexDefaultPostForm := c.DefaultPostForm("sex", "male")
    // nameDefaultPostForm := c.DefaultPostForm("name", "惜寞")
    // c.JSON(200, gin.H{
    //  "organizationPostForm":        organizationPostForm,
    //  "organizationDefaultPostForm": organizationDefaultPostForm,
    //  "sexPostForm":                 sexPostForm,
    //  "sexDefaultPostForm":          sexDefaultPostForm,
    //  "namePostForm":                namePostForm,
    //  "nameDefaultPostForm":         nameDefaultPostForm,
    // })

    // // GetPostForm 获取key对应的值，并且返回bool标识，标识成功或者失败
    // // name=ximo&age=3&sex=
    // nameGetPostForm, nameExist := c.GetPostForm("name")
    // sexGetPostForm, sexExist := c.GetPostForm("sex")
    // organizationGetPostForm, orgaorganizationExist := c.GetPostForm("organization")
    // c.JSON(200, gin.H{
    //  "nameGetPostForm":         nameGetPostForm,
    //  "nameExist":               nameExist,
    //  "sexGetPostForm":          sexGetPostForm,
    //  "sexExist":                sexExist,
    //  "organizationGetPostForm": organizationGetPostForm,
    //  "orgaorganizationExist":   orgaorganizationExist,
    // })

    // // PostFormArray 获取key对应的值，值是一个字符串数组，不存在返回空字符串数组
    // // name=ximo&age=3&sex=&hobby=code&hobby=sleep&hobby=
    // hobbyPostForm := c.PostForm("hobby")
    // hobbyPostFormArray := c.PostFormArray("hobby")
    // namePostFormArray := c.PostFormArray("name")
    // sexPostFormArray := c.PostFormArray("sex")
    // organizationPostFormArray := c.PostFormArray("organization")
    // c.JSON(200, gin.H{
    //  "hobbyPostForm":             hobbyPostForm,
    //  "hobbyPostFormArray":        hobbyPostFormArray,
    //  "namePostFormArray":         namePostFormArray,
    //  "sexPostFormArray":          sexPostFormArray,
    //  "organizationPostFormArray": organizationPostFormArray,
    // })

    // // GetPostFormArray 获取key对应的值，并且返回bool标识，标识成功或者失败
    // // name=ximo&age=3&sex=&hobby=code&hobby=sleep&hobby=
    // hobbyGetPostFormArray, hobbyExist := c.GetPostFormArray("hobby")
    // nameGetPostFormArray, nameExist := c.GetPostFormArray("name")
    // sexGetPostFormArray, sexExist := c.GetPostFormArray("sex")
    // organizationGetPostFormArray, orgaorganizationExist := c.GetPostFormArray("organization")
    // c.JSON(200, gin.H{
    //  "hobbyGetPostFormArray":        hobbyGetPostFormArray,
    //  "hobbyExist":                   hobbyExist,
    //  "nameGetPostFormArray: ":       nameGetPostFormArray,
    //  "nameExist":                    nameExist,
    //  "sexGetPostFormArray":          sexGetPostFormArray,
    //  "sexExist":                     sexExist,
    //  "organizationGetPostFormArray": organizationGetPostFormArray,
    //  "orgaorganizationExist":        orgaorganizationExist,
    // })

    // // PostFormMap 获取key对应的值，值是一个字符串map[string]string，不存在返回空
    // // user[name]=ximo&user[age]=3&user[sex]=&user[hobby]=code&user[hobby]=sleep
    // userPostFormMap := c.PostFormMap("user")
    // adminPostFormMap := c.PostFormMap("admin")
    // c.JSON(200, gin.H{
    //  "userPostFormMap":  userPostFormMap,
    //  "adminPostFormMap": adminPostFormMap,
    // })

    // // GetPostFormMap 获取key对应的值，值是一个字符串map[string]string，并且返回bool标识，标识成功或者失败
    // // user[name]=ximo&user[age]=3&user[sex]=&user[hobby]=code&user[hobby]=sleep
    // userGetPostFormMap, userExist := c.GetPostFormMap("user")
    // adminGetPostFormMap, adminExist := c.GetPostFormMap("admin")
    // c.JSON(200, gin.H{
    //  "userGetPostFormMap":  userGetPostFormMap,
    //  "userExist":           userExist,
    //  "adminGetPostFormMap": adminGetPostFormMap,
    //  "adminExist":          adminExist,
    // })
}

func main() {
    r := gin.Default()

    r.POST("/post-form", PostForm)

    r.Run(":8080")
}
```

# GetRawData 原始参数
我们如果想去获取前端传来的 JSON 数据类型就需要用到这个方法，但是实际上 Gin 帮我们封装了一种更简便的方式（参数绑定里的 ShouldBindJSON 方法），所以这个方法我们很少会用到，因此不专门去讲，有兴趣了解的可以看看

利用 GetRawData 方法可以获取请求体中 body 的内容，我们也是通过这种方式来获取前端给我们传来的 JSON 数据，但实际上通过这个方法我们不仅仅是可以获取 JSON ，还可以获取很多别的一些数据类型像是 xml、html 等等，这里我们仅仅是用获取 JSON 数据为例：
```go
package main

import (
    "encoding/json"
    "fmt"

    "github.com/gin-gonic/gin"
)

func Raw(c *gin.Context) {
    // GetRawData 实际上是去获取 request.body 中的内容
    // 它返回两个参数，一个是获取到的 []byte 类型的 body 数据，另一个是 error 类型
    // 这里忽略了 error 的处理
    data, _ := c.GetRawData()

    // 打印 data 可以看到传过来的原始数据
    fmt.Println(data)

    // 将 []byte 转成 string 类型可以看它实际传过来的内容
    fmt.Println(string(data))
  
    // 注：下面是对 JSON 数据类型的处理
    // 我们可以通过 json 包里的 Unmarshal 来对 JSON 数据类型进行反序列化
    // 就是我前几节课所说的用 JSON 中的数据去给结构体和 map 类型变量赋值

    // 1.结构体，tag 在反序列化的时候依旧可用，会根据 tag 将对应的值赋给对应的键
    type UserInfo struct {
        Name string `json:"name"`
        Age  int    `json:"age"`
        Sex  string `json:"sex"`
    }

    var userStruct UserInfo

    // JSON 反序列化，会返回一个 error，这里忽略了对其的处理
    _ = json.Unmarshal(data, &userStruct)

    c.JSON(200, userStruct)

    // // 2.map
    // var userMap map[string]interface{}

    // _ = json.Unmarshal(data, &userMap)
  
    // //获取 JSON 中的 key，注意使用 ["key"] 获取
    // // name := userMap["name"]
    // // age := userMap["age"]
    // // sex := userMap["sex"]

    // c.JSON(200, userMap)
}

func main() {
    r := gin.Default()

    r.POST("/raw", Raw)

    r.Run()
}
```
我们将上面的代码运行起来，然后可以利用 apifox 新建一个快捷请求去查看效果：
![_EY_4Z_PGRR_H_QKZ_QOPHU.png](https://img1.imgtp.com/2023/07/13/IsmjGIUz.png)

发送请求后的结果如下：
![_P_B7RI_YXG__H_SQ57FC4K.png](https://img1.imgtp.com/2023/07/13/1yu5vlul.png)

说明我们成功的收到了前端传来的 JSON 参数并且解析到了我们的结构体和 map 上，并将其响应返回给了前端

# Bind 参数绑定
下面是 Gin 的官方文档给出的介绍：
Gin提供了两类绑定方法：
- **Type** - Must bind
    - **Methods** - `Bind`, `BindJSON`, `BindXML`, `BindQuery`, `BindYAML`
    - **Behavior** - 这些方法属于 `MustBindWith` 的具体调用。 如果发生绑定错误，则请求终止，并触发 `c.AbortWithError(400, err).SetType(ErrorTypeBind)`。响应状态码被设置为 400 并且 `Content-Type` 被设置为 `text/plain; charset=utf-8`。 如果您在此之后尝试设置响应状态码，Gin会输出日志 `[GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422`。 如果您希望更好地控制绑定，考虑使用 `ShouldBind` 等效方法。
- **Type** - Should bind
    - **Methods** - `ShouldBind`, `ShouldBindJSON`, `ShouldBindXML`, `ShouldBindQuery`, `ShouldBindYAML`
    - **Behavior** - 这些方法属于 `ShouldBindWith` 的具体调用。 如果发生绑定错误，Gin 会返回错误并由开发者处理错误和请求。

使用 Bind 方法时，Gin 会尝试根据 Content-Type 推断如何绑定。 如果你明确知道要绑定什么，可以使用 `MustBindWith` 或 `ShouldBindWith`。

你也可以指定必须绑定的字段。 如果一个字段的 tag 加上了 `binding:"required"`，但绑定时是空值, Gin 会报错。

+ 我们一般不会使用 Must Bind 相关的绑定方法，因为绑定一旦发生错误，就会修改你的响应状态码，不便于你对绑定状态的控制
+ 通常使用 Should Bind 方法，发生绑定错误可以自由进行处理

简单来说：
为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的 `Content-Type` 识别请求数据类型并利用反射机制自动提取请求中 `Query`、`Param`、`Form`、`JSON` 等参数到结构体中。 下面的示例代码演示了 `ShouldBind()` 强大的功能，它能够基于请求自动提取相应类型的数据，并把值绑定到指定的结构体对象中
```go
package main

import (
    "net/http"

    "github.com/gin-gonic/gin"
)

type UserInfo struct {
    Name string `form:"name_form" uri:"name_uri" json:"name_form" binding:"required"` // binding:"required" tag 表示该属性值不能为空
    Age  int    `form:"age_form" uri:"age_uri" json:"age_form"`
    Sex  string `form:"sex_form" uri:"sex" json:"sex_form"`
}

func main() {
    r := gin.Default()

    // 对应反射 tag form
    // 绑定 Query 示例
    // 1. /query?name_form=ximo&age_form=3&sex_form=male 正常响应
    // 2. /query?name_form=ximo&age_form=3&sex_form= 或 /query?name_form=ximo&age_form=3 正常响应
    // 3. /query?age_form=3&sex_form=male 或 /query?name_form=&age_form=3&sex_form=male 返回 error，binding:"required" tag 表示 Name 属性值不能为空
    r.GET("/query", func(c *gin.Context) {
        var user UserInfo

        // 根据请求的 Content-type 自动识别请求数据类型并利用反射机制自动提取请求中的参数到结构体中
        // 会返回一个 error 参数
        err := c.ShouldBind(&user)
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": err.Error(),
            })
            return
        }

        c.JSON(200, user)
    })

    // 对应反射 tag uri
    // 绑定 Param 的示例 /param/ximo/3/male
    r.POST("/param/:name_uri/:age_uri/:sex_uri", func(c *gin.Context) {
        var user UserInfo

		// 获取 Param 比较特殊，不能直接通过 ShouldBind 绑定
        err := c.ShouldBindUri(&user)
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": err.Error(),
            })
            return
        }

        c.JSON(200, user)
    })

    // 对应反射 tag json
    // 绑定 JSON 的示例
    // 1. {"user_json": "ximo", "age_json": 3, "sex_json": male} 正常响应
    // 2. {"user_json": "ximo", "age_json": 3} 或 {"user_json": "ximo", "age_json": 3, "sex_json":""} 正常响应
    // 3. {"age_json": 3, "sex_json": male} 或 {"user_json": "", "age_json": 3, "sex_json": male}返回 error，binding:"required" tag 表示 Name 属性值不能为空
    r.POST("/json", func(c *gin.Context) {
        var user UserInfo

        err := c.ShouldBind(&user)
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": err.Error(),
            })
            return
        }

        c.JSON(200, user)
    })

    // 对应反射 tag form（和 Query 相同）
    // 绑定 form 表单示例
    // 1. name_form=ximo&age_form=3&sex_form=male 正常响应
    // 2. name_form=ximo&age_form=3&sex_form= 或 name_form=ximo&age_form=3 正常响应
    // 3. age_form=3&sex_form=male 或 name_form=&age_form=3&sex_form=male 返回 error，binding:"required" tag 表示 Name 属性值不能为空
    r.POST("/post-form", func(c *gin.Context) {
        var user UserInfo

        err := c.ShouldBind(&user)
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": err.Error(),
            })
            return
        }
  
        c.JSON(200, user)
    })

    r.Run()
}
```
+  `Should Bind` 会按照下面的顺序解析请求中的数据完成绑定：
	+ 1. 如果是 `GET` 请求，只使用 `Form` 绑定（`query`）
	+ 2. 其他请求，根据 `Content-Type` 自动识别对应类型，匹配不上会默认使用 `Form`（`form-data`）

+ 如果你明确知道要绑定什么数据类型，推荐直接使用 `ShouldBindWith`
+ 比如你明确接收到的是一个 JSON 数据，就可以使用 
	+ `ShouldBindWith(&user, binding.JSON)`
	+ 或者 `ShouldBindJSON(&user)` （实际上是上面方法的缩写，通常写这个）

我们主要知道如何用 ShouldBindJSON 去获取前端发送过来的 JSON 数据就可以了
```go
package main

import (
    "net/http"

    "github.com/gin-gonic/gin"
)

type UserInfo struct {
    Name string `json:"name" binding:"required"`
    Age  int    `json:"age"`
    Sex  string `json:"sex"`
}

func main() {
    r := gin.Default()
  
    r.POST("/json", func(c *gin.Context) {
        var user UserInfo
  
        // 绑定 JSON，接收前端发送过来的 JSON 数据
        err := c.ShouldBindJSON(&user)
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": err.Error(),
            })
            return
        }

        c.JSON(200, user)
    })
  
    r.Run()
}
```