Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如**登录认证、权限校验、数据分页、记录日志、耗时统计**等。
中间件本质上是一个 handler，可以作用在单路由、路由组和全局的 Engine。

# 定义中间件
+ Gin中的中间件必须是一个 `gin.HandlerFunc` 类型，其实和我们的处理函数是同样的类型。
+ 下面其实就是一个中间件，只不过没有什么实际的作用：
```go
func m1(c *gin.Context) {
    fmt.Println("这是一个中间件")
    
    // 中间件也可以返回响应
    c.JSON(200, gin.H{
        "msg": "中间件",
    })
}
```

我们可以把它注册到我们的路由当中：
```go
func main() {
    r := gin.Default()

	// 将 m1 作为一个中间件注册到该路由
    r.GET("/", m1, func(c *gin.Context) {
        fmt.Println("这是处理函数")

        c.JSON(200, gin.H{
            "msg": "处理函数",
        })
    })

    r.Run()
}
```
+ 实际上访问 127.0.0.1:8080/ 的时候会返次两个响应，但是我们基本不会这么写，一次请求对应多次响应是不准确也是不安全的，仅仅是用来做一个示例
+ 根据打印和响应我们也可以发现执行顺序是中间件在处理函数之前

## Abort() 和 Next()
+ `Abort()`
	+ 会中止当前请求，不执行该语句后面的所有内容，即使后面可能处理函数都没有执行
	+ 注意和 return 不同，return 直结束该函数内的内容，不影响后续函数的执行
+ `Next()` 
	+ 从当前 handler 的调用位置跳到下一个 handler 执行，执行完后续 handler（如果没有再次调用 next ），再返回上一个 next 调用位置继续往下执行
```go
func m1(c *gin.Context) {
    fmt.Println("m1 in...")

    // 跳到下一个 handler
    c.Next()
  
    fmt.Println("m1 out...")
}

func m2(c *gin.Context) {
    fmt.Println("m2 in...")

    // 跳到下一个 handler
    c.Next()

    fmt.Println("m2 out...")
}
  
func main() {
    r := gin.Default()

    r.GET("/", m1, m2, func(c *gin.Context) {
        fmt.Println("/ in...")

        fmt.Println("/ out...")
    })

    r.Run()
}
```
+ 这里写了两个中间件 m1 和 m2，遇到 Next 后会跳转到下一个 Handler
+  本质上就是一个函数嵌套调用的过程
+  ![](https://image.bluebird.icu/img/0866b73a-4d10-4d7d-adcf-7ac6c9483a4f.webp)
所以运行后的输出结果为：
```go
m1 in...
m2 in...
/ in...
/ out...
m2 out...
m1 out...
```

如果将 m1 中的 `c.Next()` 换成 `c.Abort()`
```go
func m1(c *gin.Context) {
    fmt.Println("m1 in...")

    // 终止当前请求，后续函数和代码都不会执行
    c.Abort()
  
    fmt.Println("m1 out...")
}
```

运行后的输出结果为：
```go
m1 in...
```
运行到 Abort() 就结束了

## Set() 和 Get()
+ 用于中间件（handler）之间的通信，可以是在 handler 之内，也可以是之间
+ 因为中间件实际上是不同的函数，在不同的函数之间我们不能直接传递数据，想要传递数据就需要用到 Gin 给我们封装好的 Context 中的 Set 和 Get 方法
+ `Set`：用于在请求上下文中设置数据。可以使用 `c.Set(key, value)` 方法将某个键和对应的值存储到请求上下文中
+ `Get`：用于从请求上下文中获取数据。可以使用 `c.Get(key)` 方法根据键获取在请求上下文中存储的值
+ 先 Set 再 Get
```go
type UserInfo struct {
    Name string
    Age  int
}

func m1(c *gin.Context) {
    user := UserInfo{
        Name: "XiMo",
        Age:  3,
    }

    // 将 user 以键值对的形式存储到 Context 中
    c.Set("user", user)
}

func main() {
    r := gin.Default()

    r.GET("/", m1, func(c *gin.Context) {
        // 根据 key 返回 value（any 类型）和一个 bool 值
        // bool 值用来判断是否有这个 key
        user, ok := c.Get("user")
        fmt.Println(gin.H{
            "userExist": ok,
        })

        // 断言，会返回断言类型的值和一个 bool 值
        // bool 值用来判断是否断言成功
        // 断言失败，返回的值为断言类型的零值
        _user, _ok := user.(UserInfo)
        fmt.Println(gin.H{
            "type assertion": _ok,
        })

        fmt.Println(_user)
    })
  
    r.Run()
}
```

## 记录接口耗时的中间件
我们可以写一个中间件用来记录接口耗时
```go
// StatCost 是一个统计请求耗时的中间件
func StatCost(c *gin.Context) {
    // 请求开始的时间
    start := time.Now()

	// 请求前

    // 调用该请求的剩余处理程序
    c.Next()

	// 请求后

    // 计算耗时
    cost := time.Since(start)

    // 日志形式打印
    log.Println(cost)
}
```

# 注册中间件
在gin框架中，我们可以为每个路由添加任意数量的中间件。
## 为全局路由注册
```go
func main() {
    r := gin.Default()

	// 全局注册 StatCost 中间件
    r.Use(StatCost)

    r.GET("/", func(c *gin.Context) {
        // 停1秒
        time.Sleep(time.Second)

        c.JSON(200, gin.H{
            "msg": "Hello 精弘!",
        })
    })

    r.Run()
}
```
+ 我们之前所讲的 `gin.Default()` 实际上就默认帮我们注册了两个全局中间件 `Logger()` 和  `Recovery()`
+ 如果不想集成这两个中间件可以使用 `gin.New()` 方法


## 为某个路由单独注册
```go
// 给 / 路由单独注册中间件（可注册多个）
	r.GET("/", StatCost, func(c *gin.Context) {
		// 停1秒
        time.Sleep(time.Second)

        c.JSON(200, gin.H{
            "msg": "Hello 精弘!",
        })
	})
```

## 为路由组注册中间件
为路由组注册中间件有以下两种写法。
写法1：
```go
user := r.Group("/user", StatCost)
{
    user.POST("/register", func(c *gin.Context) {...})
    user.POST("/login", func(c *gin.Context) {...})
    user.POST("/exit", func(c *gin.Context) {...})
}
```

写法2：
```go
user := r.Group("/user")
user.Use(StatCost)
{
    user.POST("/register", func(c *gin.Context) {...})
    user.POST("/login", func(c *gin.Context) {...})
    user.POST("/exit", func(c *gin.Context) {...})
}
```

通过路由组注册中间件易于定义中间件的使用范围
比如我只有 /admin 相关的路由需要鉴权，判断是不是管理员，就可以通过路由组的方式去管理，而不需要单个一个个的注册或者全局注册（没有必要给所有路由都加上该中间件）
